<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
</head>

<body>

    <script>
        // --------------------------------  РЕГУЛЯРНОЕ ВЫРАЖЕНИЕ  --------------------------------------------
        /* 
        Регулярное выражение (оно же «регэксп», «регулярка» или просто «рег»), состоит из:
        шаблона (также говорят «паттерн») 
        и необязательных флагов. 

        В JavaScript регулярные выражения реализованы отдельным объектом RegExp и интегрированы в методы строк.

        ---- «Длинный» синтаксис: 
        */
        // regexp = new RegExp("шаблон", "флаги");

        //--- короткий синтаксис, использующий слеши "/":

        // regexp = /шаблон/; // без флагов
        // regexp = /шаблон/gmi; // с флагами gmi (будут описаны далее)

        /* 
        Основная разница между этими двумя способами создания заключается в том, что слеши /.../ не допускают
        никаких вставок переменных (наподобие возможных в строках через ${...}). Они полностью статичны.
        */

        // -------------------------------------  ФЛАГИ  -------------------------------------------------------

        /* 
        ----- Флаги:

        i - С этим флагом поиск не зависит от регистра: нет разницы между A и a.

        g - С этим флагом поиск ищет все совпадения, без него – только первое.

        m - Многострочный режим.
            Он влияет только на поведение ^ и $. Ищет совпадение в начале или конце каждой строки, и после \n (перевода строки)

        s - Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n.

        u - Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар.
            Работает поиск по юникодным свойствам \p{…}. (подробнее - сами =) )

        y - Режим поиска на конкретной позиции в тексте. 

        */

        // -----------------------------------  МЕТОДЫ СТРОК   ---------------------------------------------------


        // -------------------- str.match
        /* 
        ------ Поиск: str.match:

        Метод str.match(regexp) для строки str возвращает совпадения с регулярным выражением regexp. 
        */

        // let str = "Любо, братцы, любо!";

        // alert(str.match(/любо/gi)); // Любо,любо (массив из 2х подстрок-совпадений). 

        // g - массив всеx совпадиний (если нет то вернет просто null), i - нет регистрозависимости;



        // ------------------- str.replace

        /* 
        ----- Метод str.replace(regexp, replacement):

        заменяет совпадения с regexp в строке str на replacement (все, если есть флаг g, иначе только первое). 
        */

        // без флага g
        // alert("We will, we will".replace(/we/i, "I")); // I will, we will

        // с флагом g
        // alert("We will, we will".replace(/we/ig, "I")); // I will, I will


        // В строке замены replacement мы можем использовать специальные комбинации символов для вставки фрагментов совпадения:

        /* 1) $& - вставляет всё найденное совпадение */
        // alert("Люблю HTML".replace(/HTML/, "$& и JavaScript")); // Люблю HTML и JavaScript


        /* 2) $` - вставляет часть строки до совпадения */
        // alert("Люблю HTML".replace(/HTML/, "$` и JavaScript")); // Люблю Люблю  и JavaScript


        /* 3) $' - вставляет часть строки после совпадения */
        // alert("Люблю HTML очень".replace(/HTML/, "$' и JavaScript")); // Люблю  очень и JavaScript очень


        /* 4) $n - если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения */


        /* 5) $<name> -вставляет содержимое скобочной группы с именем name, также изучим в главе Скобочные группы */


        /* 6) $$ - вставляет символ "$"  */
        // alert("Люблю HTML".replace(/HTML/, "$$ и JavaScript")); // Люблю $ и JavaScript


        // ---------------- regexp.test(str)


        /* 
        ----- Метод regexp.test(str) возвращает true, если есть хоть одно совпадение, иначе false. 
        */
        // let str = "Я ЛюБлЮ JavaScript";
        // let regexp = /люблю/i;

        // alert( regexp.test(str) ); // true



        // ------------------------------  СИМВОЛЬНЫЕ КЛАССЫ  -------------------------------------------

        /* 
        --- Символьные классы:
        Символьный класс – это специальное обозначение, которое соответствует любому символу из определённого набора. */

        /* Существуют следующие символьные классы:

        \d – цифры.
        \D – не цифры.

        \s – пробельные символы, табы, новые строки.
        \S – все, кроме \s.

        \w – латиница, цифры, подчёркивание '_'.
        \W – все, кроме \w.

        . – любой символ, если с флагом регулярного выражения s, в противном случае любой символ, кроме перевода строки \n. */

        // let str = "+7(903)-123-45-67";
        // alert( str.match(/\d/g) ); // массив совпадений: 7,9,0,3,1,2,3,4,5,6,7
        // alert(str.match(/\D/g)); // массив совпадений: +,(,),-,-,-

        // let str = "Hello_friend (123)";
        // alert(str.match(/\w/g)); // массив совпадений: H,e,l,l,o,_,f,r,i,e,n,d,1,2,3
        // alert(str.match(/\W/g)); // массив совпадений:  ,(,)


        // -------------------------------------  ЯКОРЯ  -----------------------------------------------

        /* 
        ----- Якоря: 
        */
        //  ^ - означает совпадение с началом текста

        // let str1 = "Mary had a little lamb";
        // alert( /^Mary/.test(str1) ); // true

        //  $ - означает совпадение с концом текста

        // let str1 = "it's fleece was white as snow";
        // alert( /snow$/.test(str1) ); // true

        // ^...$ - проверка на полное совпадение

        // let goodInput = "12:34";
        // let badInput = "12:345";

        // alert( /^\d\d:\d\d$/.test(goodInput) ); // true
        // alert( /^\d\d:\d\d$/.test(badInput) ); // false


        // -------------------------------------  ГРАНИЦА СЛОВА  -----------------------------------------

        /* 
        Граница слова \b – проверка, как ^ и $.

        Есть три вида позиций, которые являются границами слова:
        */

        // 1) Начало текста, если его первый символ \w.

        // alert( "Hello, Java!".match(/\bJava\b/) ); // Java

        // 2) Позиция внутри текста, если слева находится \w, а справа – не \w, или наоборот.

        // alert("My email, hello.com!".match(/\bhello\b/)); // hello

        // 3) Конец текста, если его последний символ \w.

        // alert( "Hello, JavaScript!".match(/\bJava\b/) ); // null

        // !!!!!!!!!!!!!!!!! Граница слова \b не работает для алфавитов, не основанных на латинице !!!!!!!!!!!!



        // -------------------------------------  ЭКРАНИРОВАНИЕ, СПЕЦ СИМВОЛЫ  --------------------------------

        /* 

        \   это экран;

        [ \ ^ $ . | ? * + ( )  это спец символы или (пока не запоминайте но знайте)
        
        что бы спец символ в регулярном выражении воспринимался как обычный (например мы ищем что-то где есть скобки () )
        нужно экранировать спец символ - вот так \(

            alert( "function g()".match(/g\(\)/) ); // "g()"
        
        */

        /* 
        ----- Символ косой черты '/', так называемый «слэш», не является специальным символом,
        но в JavaScript он используется для открытия и закрытия регулярного выражения: /...шаблон.../,
        поэтому мы должны экранировать его. 
        */

        // ----- Про new RegExp:

        // let regexp = new RegExp("\d\.\d"); // Не сработает как в примерах выше

        // alert( "Глава 5.1".match(regexp) ); // null

        /* 
        Строковые кавычки «съедают» символы обратной косой черты для себя, например:

            \n – становится символом перевода строки,
            \u1234 – становится символом Юникода с указанным номером,
            …А когда нет особого значения: как например для \d или\z, обратная косая черта просто удаляется. 
        */
        //    !!!!! если используете синтаксис new RegExp, то надо удваивать косую черту - \\ !!!!!!
        // Каждый раз одну косую черту приносим в жертву строковым кавычкам =)


        // -------------------------------------  НАБОРЫ и ДИАПАЗОНЫ [...]  --------------------------------


        /* 
        ------- Наборы
        Несколько символов или символьных классов в квадратных скобках […] означают «искать любой символ из заданных».
        Для примера, [eao] означает любой из 3-х символов: 'a', 'e' или 'o'. 
        */
        // найти [т или х], после которых идёт "оп"
        // alert( "Топ хоп".match(/[тх]оп/gi) ); // "топ", "хоп"

        /* 
        ------- Диапазоны
        Ещё квадратные скобки могут содержать диапазоны символов. Для этого между символами ставится знак "-". 
        тогда поиск будет верен для всех ["от"-"до"]. Какие символы находятся в том или инном диапазоне можно узнать из
        таюлицы символов Юникода. https://unicode-table.com/ru/ 
        ---многоязычный аналог \w - [a-zA-Z0-9_]
        */
        // alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF

        // выше мы ищем "x", за которым следуют две цифры или буквы от A до F

        /* 
        ------ Исключающие диапазоны
            Помимо обычных диапазонов, есть «исключающие» диапазоны, которые выглядят как [^…].
            Добавив "^" теперь мы будем искать кроме того что в квадратных скобках. 
        */

        // let str = "Hello_friend (123)";
        // alert(str.replace(/_/, ' ').match(/[^0-9\(\)]/gi).join('')); // Hello friend 



        // -------------------------------------  Квантификаторы +, *, ? и {n}  --------------------------------

        // ---- Количество {n}

        /* 
        Число в фигурных скобках: {n}.
        Он добавляется к символу (или символьному классу, или набору [...] и т.д.) и указывает, сколько их нам нужно.
        */

        // Точное количество: {5}
        // Шаблон \d{5} обозначает ровно 5 цифр, он эквивалентен \d\d\d\d\d.

        // alert( "Мне 12345 лет".match(/\d{5}/) ); //  "12345"

        // Диапазон: {3,5}, от 3 до 5
        // Для того, чтобы найти числа от 3 до 5 цифр, мы можем указать границы в фигурных скобках: \d{3,5}

        // alert( "Мне не 12, а 1234 года".match(/\d{3,5}/) ); // "1234"

        // Тогда шаблон \d{3,} найдёт последовательность чисел длиной 3 и более цифр:

        // alert( "Мне не 12, а 345678 лет".match(/\d{3,}/) ); // "345678"


        // ------ Короткие обозначения +, *, ?

        // "+" - Означает «один или более». То же самое, что и {1,}.
        // let str = "+7(903)-123-45-67";
        // alert( str.match(/\d+/g) ); // 7,903,123,45,67

        // "?" - Означает «ноль или один». То же самое, что и {0,1}.
        // let str = "Следует писать color или colour?";
        // alert( str.match(/colou?r/g) ); // color, colour

        // "*" - Означает «ноль или более». То же самое, что и {0,}.
        // alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1


        // --------------------------------  Жадные и ленивые квантификаторы  --------------------------------

        // -----Жадный поиск

        // let regexp = /".+"/g; 
        // (кавычка, любой символ один и более раз, кавычка). Не работает из-за жадности ".+"
        // захватит все что только возможно, а потом поймет что строка закончиласть и второй кавычки так и не нашел,
        // поэтому начнет отступать назад в ее поиске.

        // let str = 'a "witch" and her "broom" is one';

        // alert(str.match(regexp)); // "witch" and her "broom"

        // ----Ленивый режим
        /* 
            «Ленивый» режим противоположен «жадному». Он означает: «повторять квантификатор наименьшее количество раз».

            Мы можем включить его, вставив знак вопроса '?' после квантификатора, то есть будет *? или +? или даже ?? для '?'.

            Проясним: обычно знак вопроса ? сам по себе является квантификатором (ноль или один),
            но, если он добавлен после другого квантификатора (или даже после самого себя),
            он получает другое значение – он меняет режим совпадения с жадного на ленивый. 
        */

        // let regexp = /".+?"/g;
        // (кавычка, любой символ один и более раз (? - говорит "господи,лучше бы один, мне так лень") , кавычка).
        // найдет кавычку, затем начнет искать символ и в надежде что он только один, попытается закончить и на следеющей позиции
        // будет искать вторую кавычку, если не найдет, то расстроенный вернется к поиску символов ".+", и так каждый раз =/.
        // Поэтому в этом случае все отработает как ожидалось.

        // let str = 'a "witch" and her "broom" is one';

        // alert( str.match(regexp) ); // witch, broom


        // --------------------------------  Скобочны и Именованные группы  --------------------------------

        /* 
        -----Скобочные группы

        Часть шаблона можно заключить в скобки (...). Это называется «скобочная группа».

        У такого выделения есть два эффекта:

        1) Позволяет поместить часть совпадения в отдельный массив (если без флага g).
        2) Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу. 
        */

        // alert( 'Gogogo now!'.match(/(go)+/i) ); // "Gogogo"

        /* 
        Метод str.match(regexp), если у регулярного выражения regexp нет флага g, ищет первое совпадение и возвращает его в виде массива:

        На позиции 0 будет всё совпадение целиком.
        На позиции 1 – содержимое первой скобочной группы.
        На позиции 2 – содержимое второй скобочной группы.
        …и так далее… 
        */

        // let str = '<h1>Hello, world!</h1>';

        // let tag = str.match(/<(.*?)>/);

        // alert( tag[0] ); // <h1>
        // alert( tag[1] ); // h1

        /* 
        -----Именованные группы

        Запоминать группы по номерам не очень удобно. Для простых шаблонов это допустимо,
        но в сложных регулярных выражениях считать скобки затруднительно. Гораздо лучше – давать скобкам имена.

        Это делается добавлением ?<name> непосредственно после открытия скобки.

        Например, поищем дату в формате «день-месяц-год»: 
        */

        // let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
        // let str = "2019-04-30";

        // let groups = str.match(dateRegexp).groups;

        // alert(groups.year); // 2019
        // alert(groups.month); // 04
        // alert(groups.day); // 30

        /* 
        ----Скобочные группы при замене

        Метод str.replace(regexp, replacement), осуществляющий замену совпадений с regexp в строке str, 
        позволяет использовать в строке замены содержимое скобок. Это делается при помощи обозначений вида $n, 
        где n – номер скобочной группы.
        Для именованных скобок ссылка будет выглядеть как $<имя>. 
        */
        // let regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

        // let str = "2019-10-30, 2020-01-01";

        // alert( str.replace(regexp, '$<day>.$<month>.$<year>') ); // 30.10.2019, 01.01.2020

        /* 
        ---- Исключение из запоминания через ?:

        Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало ?:. 
        */


        // --------------------------------  Альтернация (или) |  --------------------------------
        // В регулярных выражениях она обозначается символом вертикальной черты |.



        // -------------------------  Опережающие и ретроспективные проверки  ---------------------

        // -----Опережающая проверка
        // Синтаксис опережающей проверки: X(?=Y).
        // Он означает: найди X при условии, что за ним следует Y. Вместо X и Y здесь может быть любой шаблон.

        // -----Негативная опережающая проверка

        // Синтаксис: X(?!Y)
        // Он означает: найди такой X, за которым НЕ следует Y.

        // -----Ретроспективная проверка

        // Синтаксис:
        // Позитивная ретроспективная проверка: (?<=Y)X, ищет совпадение с X при условии, что перед ним ЕСТЬ Y.
        // Негативная ретроспективная проверка: (?<!Y)X, ищет совпадение с X при условии, что перед ним НЕТ Y.

        // ------------------------------------------- КОНЕЦ -----------------------------

        /* Тут было описано много методов RegExp и String. Все они собраны в одном месте по адресу
        https://learn.javascript.ru/regexp-methods */
    </script>
</body>

</html>